from dataclasses import field
from typing import List, TYPE_CHECKING
from qatch.connectors.base_connector import ConnectorTable
from typing_extensions import override
import logging

from distilabel.steps import GeneratorStep
import typing_extensions

if TYPE_CHECKING:
    from distilabel.typing import StepColumns, GeneratorStepOutput

from qatch.connectors import SqliteConnector


class LoadSqliteDatabase(GeneratorStep):
    """A special kind of `Step` that is able to generate data i.e. it doesn't receive
    any input from the previous steps.

    Attributes:
        db_id: The id of the database. If not provided, it will be set to the name of the db_path
        db_path: The path to the SQLite database file.
        tables: The tables loaded from the SQLite database. It is a list of dictionaries.

    Notes:
        This step is used to load a SQLite database and generate data from it.
        The tables are loaded into a list of dictionaries where each dictionary represents a
        table and its columns. The keys of the dictionary:
        - `db_path`: The path to the SQLite database file.
        - `db_id`: The id of the database. If not provided, it will be set to the name of the db_path.
        - `db_schema`: The schema of the database.
        - `db_schema_table`: The schema of the table.
        - `tbl_name`: The name of the table.
        - `tbl_col2metadata`: A dictionary mapping from table column names to their metadata.
            - `column_name`: The column name in the table.
            - `column_type`: The datatype of the column, can be either 'categorical' or 'numerical'.
            - `sample_data`: A list of sample data values from the column.
        - `cat_col2metadata`: A dictionary mapping from category column names to their metadata.
        - `num_col2metadata`: A dictionary mapping from numeric column names to their metadata.
        - `primary_key`: The primary keys of the table as list of dict.
            - `column_name`: The column name in the table.
            - `column_type`: The datatype of the column, can be either 'categorical' or 'numerical'.
            - `sample_data`: A list of sample data values from the column.
        - `foreign_keys`: A list of foreign keys in the table.
            - `parent_column`: The name of the parent column involved in the foreign key relationship.
            - `child_column`: The name of the child column involved in the foreign key relationship.
            - `child_table`: The child table object in the foreign key relationship.

    Runtime parameters:
        - `batch_size`: The number of rows that will contain the batches generated by
            the step. Defaults to `50`.
    """

    db_path: str
    db_id: str | None = field(default=None)
    tables: list[dict] | None = field(default=None)

    @override
    def process(self, offset: int = 0) -> "GeneratorStepOutput":
        """Method that defines the generation logic of the step. It should yield the
        output rows and a boolean indicating if it's the last batch or not.

        Args:
            offset: The offset to start the generation from. Defaults to 0.

        Yields:
            The output rows and a boolean indicating if it's the last batch or not.
        """
        if offset:
            self.tables = self.tables[offset:]

        while self.instructions:
            batch = [{"tables": tables} for tables in self.tables[: self.batch_size]]

            batch = self._process_batch(batch)

            self.tables = self.tables[self.batch_size :]
            yield (
                batch,
                True if len(self.instructions) == 0 else False,
            )

    @property
    def outputs(self) -> "StepColumns":
        return ["tables"]

    @override
    def load(self) -> None:
        """Method to perform any initialization logic before the `process` method is
        called. For example, to load an LLM, stablish a connection to a database, etc.
        """
        self.name = "LoadSqliteDatabase"
        self._logger = logging.getLogger(f"distilabel.step.{self.name}")
        self._logger.info(f"Loading SQLite database from {self.db_path}")
        self._logger.info(f"Loading instructions from {self.db_path}")
        self.db_id = self.db_id or self.db_path.split("/")[-1].split(".")[0]
        self._logger.info(f"Set db_id {self.db_id} from {self.db_path}")
        self._load_qatch()
        self._logger.info(f"Loaded {len(self.tables)} tables from {self.db_path}")

    def _load_qatch(self):
        db_uri = f"file:{self.db_path}?immutable=1&uri=true"
        connector = SqliteConnector(
            relative_db_path=db_uri,
            db_name=self.db_id,
        )
        tbl_name2table: dict[str, ConnectorTable] = (
            connector.load_tables_from_database()
        )

        self.tables = [val.model_dump() for val in tbl_name2table.values()]
        for val in self.tables:
            val["db_id"] = val.pop("db_name", None)
            val["db_schema_table"] = connector.run_query(
                f"SELECT sql FROM sqlite_master WHERE type='table' AND name='{val['tbl_name']}'"
            )[0][0]
            val["db_schema"] = "\n".join([val[0] for val in connector.run_query(
                "SELECT sql FROM sqlite_master"
            )])
